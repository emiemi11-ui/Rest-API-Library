#include "../../include/auth/jwt.hpp"
#include <cstring>
#include <algorithm>

namespace auth {

JWT::JWT(const std::string& secret, int expiration_hours)
    : secret_(secret), expiration_hours_(expiration_hours) {}

std::string JWT::generateToken(int user_id, const std::string& username, const std::string& role) {
    // Create header
    utils::json::JSON header = utils::json::JSON::object();
    header["alg"] = "HS256";
    header["typ"] = "JWT";

    // Create payload
    utils::json::JSON payload = utils::json::JSON::object();
    payload["user_id"] = user_id;
    payload["username"] = username;
    payload["role"] = role;

    // Add timestamps
    time_t now = time(nullptr);
    payload["iat"] = static_cast<int>(now);
    payload["exp"] = static_cast<int>(now + (expiration_hours_ * 3600));

    // Encode header and payload
    std::string header_encoded = urlSafeBase64Encode(header.toString());
    std::string payload_encoded = urlSafeBase64Encode(payload.toString());

    // Create signature
    std::string data = header_encoded + "." + payload_encoded;
    std::string signature = urlSafeBase64Encode(hmacSha256(data, secret_));

    // Return JWT
    return header_encoded + "." + payload_encoded + "." + signature;
}

bool JWT::validateToken(const std::string& token) {
    try {
        // Split token
        size_t first_dot = token.find('.');
        size_t second_dot = token.find('.', first_dot + 1);

        if (first_dot == std::string::npos || second_dot == std::string::npos) {
            return false;
        }

        std::string header_encoded = token.substr(0, first_dot);
        std::string payload_encoded = token.substr(first_dot + 1, second_dot - first_dot - 1);
        std::string signature_provided = token.substr(second_dot + 1);

        // Verify signature
        std::string data = header_encoded + "." + payload_encoded;
        std::string signature_calculated = urlSafeBase64Encode(hmacSha256(data, secret_));

        if (signature_provided != signature_calculated) {
            return false;
        }

        // Check expiration
        return !isTokenExpired(token);
    } catch (...) {
        return false;
    }
}

utils::json::JSON JWT::parsePayload(const std::string& token) {
    size_t first_dot = token.find('.');
    size_t second_dot = token.find('.', first_dot + 1);

    if (first_dot == std::string::npos || second_dot == std::string::npos) {
        throw std::runtime_error("Invalid token format");
    }

    std::string payload_encoded = token.substr(first_dot + 1, second_dot - first_dot - 1);
    std::string payload_str = urlSafeBase64Decode(payload_encoded);

    return utils::json::JSON::parse(payload_str);
}

int JWT::getUserIdFromToken(const std::string& token) {
    try {
        auto payload = parsePayload(token);
        return payload["user_id"].asInt();
    } catch (...) {
        return -1;
    }
}

std::string JWT::getUsernameFromToken(const std::string& token) {
    try {
        auto payload = parsePayload(token);
        return payload["username"].asString();
    } catch (...) {
        return "";
    }
}

std::string JWT::getRoleFromToken(const std::string& token) {
    try {
        auto payload = parsePayload(token);
        return payload["role"].asString();
    } catch (...) {
        return "";
    }
}

bool JWT::isTokenExpired(const std::string& token) {
    try {
        auto payload = parsePayload(token);
        time_t exp = payload["exp"].asInt();
        time_t now = time(nullptr);
        return now > exp;
    } catch (...) {
        return true;
    }
}

// Helper methods (simplified implementations)
std::string JWT::base64Encode(const unsigned char* buffer, size_t length) {
    static const char* base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    std::string result;

    for (size_t i = 0; i < length; i += 3) {
        unsigned char b1 = buffer[i];
        unsigned char b2 = (i + 1 < length) ? buffer[i + 1] : 0;
        unsigned char b3 = (i + 2 < length) ? buffer[i + 2] : 0;

        result += base64_chars[b1 >> 2];
        result += base64_chars[((b1 & 0x03) << 4) | (b2 >> 4)];
        result += (i + 1 < length) ? base64_chars[((b2 & 0x0F) << 2) | (b3 >> 6)] : '=';
        result += (i + 2 < length) ? base64_chars[b3 & 0x3F] : '=';
    }

    return result;
}

std::string JWT::base64Decode(const std::string& input) {
    static const std::string base64_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    std::string result;

    for (size_t i = 0; i < input.length(); i += 4) {
        int val1 = base64_chars.find(input[i]);
        int val2 = base64_chars.find(input[i + 1]);
        int val3 = (input[i + 2] != '=') ? base64_chars.find(input[i + 2]) : 0;
        int val4 = (input[i + 3] != '=') ? base64_chars.find(input[i + 3]) : 0;

        result += static_cast<char>((val1 << 2) | (val2 >> 4));
        if (input[i + 2] != '=') result += static_cast<char>((val2 << 4) | (val3 >> 2));
        if (input[i + 3] != '=') result += static_cast<char>((val3 << 6) | val4);
    }

    return result;
}

std::string JWT::urlSafeBase64Encode(const std::string& input) {
    std::string encoded = base64Encode(reinterpret_cast<const unsigned char*>(input.c_str()), input.length());
    std::replace(encoded.begin(), encoded.end(), '+', '-');
    std::replace(encoded.begin(), encoded.end(), '/', '_');
    encoded.erase(std::remove(encoded.begin(), encoded.end(), '='), encoded.end());
    return encoded;
}

std::string JWT::urlSafeBase64Decode(const std::string& input) {
    std::string padded = input;
    std::replace(padded.begin(), padded.end(), '-', '+');
    std::replace(padded.begin(), padded.end(), '_', '/');

    // Add padding
    while (padded.length() % 4 != 0) {
        padded += '=';
    }

    return base64Decode(padded);
}

std::string JWT::hmacSha256(const std::string& data, const std::string& key) {
    unsigned char hash[32];
    unsigned int hash_len = 32;

    HMAC(EVP_sha256(),
         key.c_str(), key.length(),
         reinterpret_cast<const unsigned char*>(data.c_str()), data.length(),
         hash, &hash_len);

    return std::string(reinterpret_cast<char*>(hash), hash_len);
}

} // namespace auth
